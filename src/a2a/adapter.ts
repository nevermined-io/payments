/**
 * PaymentsA2AAdapter bridges user executor logic with the A2A SDK.
 * Handles credit validation, task execution, and credit burning.
 */
import { v4 as uuidv4 } from 'uuid'
import type {
  AgentExecutor,
  RequestContext,
  ExecutionEventBus,
  Task,
  TaskStatusUpdateEvent,
  TaskState,
  Message,
} from '@a2a-js/sdk'
import type { PaymentsAgentExecutor } from './executor'
import type { TaskContext, TaskHandlerResult } from './types'
import type { AgentCard } from './types'
import { PaymentsError } from '../common/payments.error'

/**
 * Global context to store bearer token for current request.
 * This is a simple way to pass bearer token from middleware to adapter.
 */
const requestContext = {
  currentBearerToken: undefined as string | undefined,
  currentUrlRequested: undefined as string | undefined,
  currentHttpMethodRequested: undefined as string | undefined,
}

/**
 * Set the current request context (called by middleware).
 */
export function setRequestContext(
  bearerToken?: string,
  urlRequested?: string,
  httpMethodRequested?: string,
) {
  requestContext.currentBearerToken = bearerToken
  requestContext.currentUrlRequested = urlRequested
  requestContext.currentHttpMethodRequested = httpMethodRequested
}

/**
 * Get the current request context (called by adapter).
 */
export function getRequestContext() {
  return {
    bearerToken: requestContext.currentBearerToken,
    urlRequested: requestContext.currentUrlRequested,
    httpMethodRequested: requestContext.currentHttpMethodRequested,
  }
}

/**
 * PaymentsA2AAdapter bridges user executor logic with the A2A SDK.
 * Handles credit validation, task execution, and credit burning.
 */
export class PaymentsA2AAdapter implements AgentExecutor {
  constructor(
    private userExecutor: PaymentsAgentExecutor,
    private paymentsService: any,
    private agentCard: AgentCard,
  ) {}

  /**
   * Extracts the agentId from the AgentCard payment extension.
   * @returns The agent ID for payment validation.
   */
  private getAgentId(): string {
    const paymentExtension = this.agentCard.capabilities?.extensions?.find(
      (ext) => ext.uri === 'urn:nevermined:payment',
    )

    if (!paymentExtension?.params?.agentId) {
      throw new Error(
        'Agent ID not found in payment extension. Make sure to include agentId in buildPaymentAgentCard.',
      )
    }

    return paymentExtension.params.agentId as string
  }

  /**
   * Executes an incoming A2A task, handling credit validation and burning.
   * @param requestContext - The A2A request context.
   * @param eventBus - The event bus for publishing A2A events.
   */
  async execute(requestContext: RequestContext, eventBus: ExecutionEventBus): Promise<void> {
    console.log('[ADAPTER] Starting task execution')

    const userMessage = requestContext.userMessage
    const existingTask = requestContext.task

    // ---
    // Extract bearer token from the global request context (set by middleware).
    // This avoids modifying req.body which causes conflicts with the A2A SDK.
    // ---
    const { bearerToken, urlRequested, httpMethodRequested } = getRequestContext()
    console.log(
      `[ADAPTER] Request context - Bearer: ${bearerToken ? 'present' : 'missing'}, URL: ${urlRequested}, Method: ${httpMethodRequested}`,
    )
    // ---

    // Use the taskId and contextId that were already generated by DefaultRequestHandler
    const taskId = requestContext.taskId || existingTask?.id
    const contextId = requestContext.contextId

    console.log(`[ADAPTER] Task info - ID: ${taskId}, Context: ${contextId}`)

    if (!taskId || !contextId) {
      console.log('[ADAPTER] Missing taskId or contextId, publishing failed task')
      await this.publishFailed(
        eventBus,
        'unknown',
        'unknown',
        'Missing taskId or contextId from request context.',
      )
      eventBus.finished()
      return
    }

    // Always publish initial task first (even if we're going to fail)
    if (!existingTask) {
      const initialTask: Task = {
        kind: 'task',
        id: taskId,
        contextId,
        status: {
          state: 'submitted',
          timestamp: new Date().toISOString(),
        },
        history: [userMessage],
        metadata: userMessage.metadata,
        artifacts: [],
      }
      eventBus.publish(initialTask)
      console.log('[ADAPTER] Published initial task')
    }

    // 0. Validate bearer token before proceeding
    if (
      !bearerToken ||
      bearerToken === 'undefined' ||
      bearerToken === 'null' ||
      bearerToken.trim() === ''
    ) {
      console.log('[ADAPTER] Invalid bearer token, publishing failed task')
      await this.publishFailed(
        eventBus,
        taskId,
        contextId,
        'Authentication failed. Please provide a valid access token.',
      )
      eventBus.finished()
      return
    }

    console.log('[ADAPTER] Bearer token validation passed, proceeding with credit validation')

    // 1. Validate credits before executing the task
    try {
      console.log('[ADAPTER] Calling isValidRequest...')
      const validation = await this.paymentsService.isValidRequest(
        this.getAgentId(),
        bearerToken,
        urlRequested,
        httpMethodRequested,
      )
      console.log('[ADAPTER] isValidRequest result:', validation)

      if (!validation?.balance?.balance || Number(validation.balance.balance) <= 0) {
        console.log('[ADAPTER] Insufficient credits, publishing failed task')
        await this.publishFailed(
          eventBus,
          taskId,
          contextId,
          'Insufficient credits or invalid request.',
        )
        eventBus.finished()
        return
      }
    } catch (err: any) {
      console.log('[ADAPTER] Error in isValidRequest:', err.message)
      if (err instanceof PaymentsError) {
        const userMessage = `Payment validation failed: ${err.message}`
        await this.publishFailed(eventBus, taskId, contextId, userMessage)
      } else {
        await this.publishFailed(
          eventBus,
          taskId,
          contextId,
          'Credit validation failed: ' + err.message,
        )
      }
      eventBus.finished()
      return
    }

    console.log('[ADAPTER] Credit validation passed, publishing working status')

    // 2. Publish "working" status update
    const workingStatusUpdate: TaskStatusUpdateEvent = {
      kind: 'status-update',
      taskId,
      contextId,
      status: {
        state: 'working',
        message: {
          kind: 'message',
          role: 'agent',
          messageId: uuidv4(),
          parts: [{ kind: 'text', text: 'Processing your request...' }],
          taskId,
          contextId,
        },
        timestamp: new Date().toISOString(),
      },
      final: false,
    }
    eventBus.publish(workingStatusUpdate)
    console.log('[ADAPTER] Published working status')

    // 3. Call the user's handler
    let handlerResult: TaskHandlerResult
    try {
      console.log('[ADAPTER] Calling user handler...')
      const context: TaskContext = {
        userMessage,
        existingTask,
        bearerToken,
        requestMetadata: userMessage.metadata,
      }
      handlerResult = await this.userExecutor.handleTask(context)
      console.log('[ADAPTER] User handler completed')
    } catch (err: any) {
      console.log('[ADAPTER] Error in user handler:', err.message)
      await this.publishFailed(eventBus, taskId, contextId, 'Task execution failed: ' + err.message)
      eventBus.finished()
      return
    }

    // 4. Burn credits after successful execution
    const creditsToBurn = handlerResult.metadata?.creditsUsed
    if (creditsToBurn && bearerToken) {
      try {
        console.log('[ADAPTER] Burning credits...')
        await this.paymentsService.redeemCreditsFromRequest(bearerToken, BigInt(creditsToBurn))
        console.log('[ADAPTER] Credits burned successfully')
      } catch (err: any) {
        console.log('[ADAPTER] Error burning credits:', err.message)
        if (err instanceof PaymentsError) {
          const userMessage = `Payment validation failed: ${err.message}`
          await this.publishFailed(eventBus, taskId, contextId, userMessage)
        } else {
          await this.publishFailed(
            eventBus,
            taskId,
            contextId,
            'Failed to process payment: ' + err.message,
          )
        }
        eventBus.finished()
        return
      }
    }

    // 5. Publish final status update (completed, input-required, etc.)
    const finalState: TaskState = handlerResult.state || 'completed'
    const agentMessage: Message = {
      kind: 'message',
      role: 'agent',
      messageId: uuidv4(),
      parts: handlerResult.parts,
      taskId,
      contextId,
      metadata: handlerResult.metadata,
    }
    const finalUpdate: TaskStatusUpdateEvent = {
      kind: 'status-update',
      taskId,
      contextId,
      status: {
        state: finalState,
        message: agentMessage,
        timestamp: new Date().toISOString(),
      },
      final: true,
    }
    eventBus.publish(finalUpdate)
    console.log('[ADAPTER] Published final status, finishing')
    eventBus.finished()
  }

  /**
   * Handles task cancellation by delegating to the user's cancelTask method.
   * @param taskId - The ID of the task to cancel.
   * @param _eventBus - The event bus for publishing cancellation events (unused in current implementation).
   */
  async cancelTask(taskId: string, _eventBus: ExecutionEventBus): Promise<void> {
    await this.userExecutor.cancelTask(taskId)
    // Optionally publish a cancellation event here if needed
  }

  /**
   * Publishes a failed task event.
   * @param eventBus - The event bus to publish to.
   * @param taskId - The task ID.
   * @param contextId - The context ID.
   * @param errorMessage - The error message.
   */
  private async publishFailed(
    eventBus: ExecutionEventBus,
    taskId: string,
    contextId: string,
    errorMessage: string,
  ): Promise<void> {
    const failedUpdate: TaskStatusUpdateEvent = {
      kind: 'status-update',
      taskId,
      contextId,
      status: {
        state: 'failed',
        message: {
          kind: 'message',
          role: 'agent',
          messageId: uuidv4(),
          parts: [{ kind: 'text', text: errorMessage }],
          taskId,
          contextId,
        },
        timestamp: new Date().toISOString(),
      },
      final: true,
    }
    eventBus.publish(failedUpdate)
  }
}
